{
  "version": 3,
  "sources": ["../lib/slice_start.js", "../lib/slice_strides.js", "../lib/empty.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Resolves the index offset of the first element indexed by a normalized multi-slice.\n*\n* @private\n* @param {MultiSlice} slice - normalized multi-slice object\n* @param {IntegerArray} strides - array strides\n* @param {NonNegativeInteger} offset - array index offset\n* @returns {NonNegativeInteger} index offset of the first element indexed by a normalized multi-slice object\n*/\nfunction sliceStart( slice, strides, offset ) {\n\tvar data;\n\tvar idx;\n\tvar i;\n\n\tdata = slice.data;\n\tidx = offset;\n\tfor ( i = 0; i < data.length; i++ ) {\n\t\tidx += strides[ i ] * data[ i ].start;\n\t}\n\treturn idx;\n}\n\n\n// EXPORTS //\n\nmodule.exports = sliceStart;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Resolves slice strides for a provided normalized multi-slice object.\n*\n* @private\n* @param {MultiSlice} slice - normalized multi-slice object\n* @param {IntegerArray} strides - array strides\n* @param {NonNegativeIntegerArray} rdims - indices of non-reduced dimensions\n* @returns {IntegerArray} slice strides\n*\n* @example\n* var Slice = require( '@stdlib/slice-ctor' );\n* var MultiSlice = require( '@stdlib/slice-multi' );\n*\n* var s = new MultiSlice( new Slice( 2, 3, 1 ), new Slice( 10, null, -2 ) );\n* // returns <MultiSlice>\n*\n* var strides = slice2strides( s, [ 8, 2 ], [ 1 ] );\n* // returns [ -4 ]\n*/\nfunction slice2strides( slice, strides, rdims ) {\n\tvar data;\n\tvar out;\n\tvar i;\n\tvar j;\n\n\tdata = slice.data;\n\tout = [];\n\tfor ( i = 0; i < rdims.length; i++ ) {\n\t\tj = rdims[ i ];\n\t\tout.push( strides[j] * data[j].step );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = slice2strides;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar buffer = require( '@stdlib/ndarray-base-buffer' );\nvar zeros = require( '@stdlib/array-base-zeros' );\n\n\n// MAIN //\n\n/**\n* Returns an empty n-dimensional ndarray.\n*\n* @private\n* @param {Function} ctor - ndarray constructor\n* @param {string} dtype - array data type\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {string} order - layout order\n* @param {boolean} readonly - boolean indicating whether a returned array should be read-only\n* @returns {ndarray} empty ndarray\n*/\nfunction empty( ctor, dtype, shape, order, readonly ) {\n\tvar strides;\n\tvar ndims;\n\n\tndims = shape.length;\n\tif ( ndims === 0 ) {\n\t\tstrides = [ 0 ];\n\t} else {\n\t\tstrides = zeros( ndims );\n\t}\n\treturn new ctor( dtype, buffer( dtype, 0 ), shape, strides, 0, order, {\n\t\t'readonly': readonly\n\t});\n}\n\n\n// EXPORTS //\n\nmodule.exports = empty;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar normalizeMultiSlice = require( '@stdlib/slice-base-normalize-multi-slice' );\nvar nonreducedDimensions = require( '@stdlib/slice-base-nonreduced-dimensions' );\nvar sliceShape = require( '@stdlib/slice-base-shape' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar getDType = require( '@stdlib/ndarray-base-dtype' );\nvar getShape = require( '@stdlib/ndarray-base-shape' );\nvar getStrides = require( '@stdlib/ndarray-base-strides' );\nvar getOffset = require( '@stdlib/ndarray-base-offset' );\nvar getOrder = require( '@stdlib/ndarray-base-order' );\nvar getData = require( '@stdlib/ndarray-base-data-buffer' );\nvar format = require( '@stdlib/string-format' );\nvar sliceStart = require( './slice_start.js' );\nvar slice2strides = require( './slice_strides.js' );\nvar empty = require( './empty.js' );\n\n\n// MAIN //\n\n/**\n* Returns a view of an input ndarray.\n*\n* @param {ndarray} x - input array\n* @param {MultiSlice} s - multi-slice object\n* @param {boolean} strict - boolean indicating whether to enforce strict bounds checking\n* @param {boolean} writable - boolean indicating whether a returned array should be writable\n* @throws {RangeError} number of slice dimensions must match the number of array dimensions\n* @throws {RangeError} slice exceeds array bounds\n* @returns {ndarray} ndarray view\n*\n* @example\n* var Slice = require( '@stdlib/slice-ctor' );\n* var MultiSlice = require( '@stdlib/slice-multi' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n* var ndarray2array = require( '@stdlib/ndarray-to-array' );\n*\n* var buffer = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];\n* var shape = [ 3, 2 ];\n* var strides = [ 2, 1 ];\n* var offset = 0;\n*\n* var x = ndarray( 'generic', buffer, shape, strides, offset, 'row-major' );\n* // returns <ndarray>\n*\n* var sh = x.shape;\n* // returns [ 3, 2 ]\n*\n* var arr = ndarray2array( x );\n* // returns [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* var s = new MultiSlice( new Slice( null, null, -2 ), new Slice( null, null, -1 ) );\n* // returns <MultiSlice>\n*\n* var y = slice( x, s, false, false );\n* // returns <ndarray>\n*\n* sh = y.shape;\n* // returns [ 2, 2 ]\n*\n* arr = ndarray2array( y );\n* // returns [ [ 6.0, 5.0 ], [ 2.0, 1.0 ] ]\n*/\nfunction slice( x, s, strict, writable ) {\n\tvar strides;\n\tvar offset;\n\tvar dtype;\n\tvar shape;\n\tvar order;\n\tvar sdims;\n\tvar ndims;\n\tvar ctor;\n\tvar sh;\n\tvar ns;\n\n\t// Retrieve array meta data:\n\tdtype = getDType( x );\n\tshape = getShape( x, true );\n\tstrides = getStrides( x, true );\n\toffset = getOffset( x );\n\torder = getOrder( x );\n\tndims = shape.length;\n\n\t// Ensure that the number of array dimensions matches the number of slices:\n\tif ( s.ndims !== ndims ) {\n\t\tthrow new RangeError( format( 'invalid argument. Number of slice dimensions does not match the number of array dimensions. Array shape: (%s). Slice dimensions: %u.', shape.join( ',' ), s.ndims ) );\n\t}\n\t// Resolve the output array constructor:\n\tctor = x.constructor;\n\n\t// If provided a zero-dimensional input array, return a zero-dimensional array view...\n\tif ( ndims === 0 ) {\n\t\treturn new ctor( dtype, getData( x ), shape, strides, offset, order, {\n\t\t\t'readonly': !writable\n\t\t});\n\t}\n\t// Resolve the indices of the non-reduced dimensions:\n\tsdims = nonreducedDimensions( s );\n\n\t// Normalize the slice object based on the array shape:\n\tns = normalizeMultiSlice( s, shape, true );\n\n\t// Check whether the slice exceeds array bounds...\n\tif ( ns.code ) {\n\t\tif ( strict ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Slice exceeds array bounds. Array shape: (%s).', shape.join( ',' ) ) );\n\t\t}\n\t\t// Normalize again, this time allowing for out-of-bounds indices:\n\t\tns = normalizeMultiSlice( s, shape, false );\n\n\t\t// Compute the slice shape:\n\t\tsh = sliceShape( ns );\n\n\t\t// If the non-reduced dimensions contain elements, this means that at least one reduced dimension exceeded array bounds; in which case, we generate a shape containing zeros:\n\t\tif ( numel( take( sh, sdims ) ) > 0 ) {\n\t\t\tsh = zeros( sh.length );\n\t\t}\n\t} else {\n\t\t// Compute the slice shape:\n\t\tsh = sliceShape( ns );\n\t}\n\t// If the slice does not contain any elements, return an empty array...\n\tif ( numel( sh ) === 0 ) {\n\t\treturn empty( ctor, dtype, take( sh, sdims ), order, !writable );\n\t}\n\t// Resolve the index offset of the first element indexed by the slice:\n\toffset = sliceStart( ns, strides, offset ); // TODO: @stdlib/ndarray/base/sind2bind\n\n\t// Remove reduced dimensions from the slice shape:\n\tsh = take( sh, sdims );\n\n\t// If all dimensions were reduced, return a zero-dimensional array...\n\tif ( sh.length === 0 ) {\n\t\treturn new ctor( dtype, getData( x ), [], [ 0 ], offset, order, {\n\t\t\t'readonly': !writable\n\t\t});\n\t}\n\t// Update strides according to slice steps:\n\tstrides = slice2strides( ns, strides, sdims ); // TODO: @stdlib/ndarray/base/slice2strides???\n\n\t// Return a slice view:\n\treturn new ctor( dtype, getData( x ), sh, strides, offset, order, {\n\t\t'readonly': !writable\n\t});\n}\n\n\n// EXPORTS //\n\nmodule.exports = slice;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Return a view of an input ndarray.\n*\n* @module @stdlib/ndarray-base-slice\n*\n* @example\n* var Slice = require( '@stdlib/slice-ctor' );\n* var MultiSlice = require( '@stdlib/slice-multi' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n* var ndarray2array = require( '@stdlib/ndarray-to-array' );\n* var slice = require( '@stdlib/ndarray-base-slice' );\n*\n* var buffer = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];\n* var shape = [ 3, 2 ];\n* var strides = [ 2, 1 ];\n* var offset = 0;\n*\n* var x = ndarray( 'generic', buffer, shape, strides, offset, 'row-major' );\n* // returns <ndarray>\n*\n* var sh = x.shape;\n* // returns [ 3, 2 ]\n*\n* var arr = ndarray2array( x );\n* // returns [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* var s = new MultiSlice( new Slice( null, null, -2 ), new Slice( null, null, -1 ) );\n* // returns <MultiSlice>\n*\n* var y = slice( x, s, false, false );\n* // returns <ndarray>\n*\n* sh = y.shape;\n* // returns [ 2, 2 ]\n*\n* arr = ndarray2array( y );\n* // returns [ [ 6.0, 5.0 ], [ 2.0, 1.0 ] ]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cA+BA,SAASC,EAAYC,EAAOC,EAASC,EAAS,CAC7C,IAAIC,EACAC,EACAC,EAIJ,IAFAF,EAAOH,EAAM,KACbI,EAAMF,EACAG,EAAI,EAAGA,EAAIF,EAAK,OAAQE,IAC7BD,GAAOH,EAASI,CAAE,EAAIF,EAAME,CAAE,EAAE,MAEjC,OAAOD,CACR,CAKAN,EAAO,QAAUC,IC/CjB,IAAAO,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAyCA,SAASC,EAAeC,EAAOC,EAASC,EAAQ,CAC/C,IAAIC,EACAC,EACAC,EACAC,EAIJ,IAFAH,EAAOH,EAAM,KACbI,EAAM,CAAC,EACDC,EAAI,EAAGA,EAAIH,EAAM,OAAQG,IAC9BC,EAAIJ,EAAOG,CAAE,EACbD,EAAI,KAAMH,EAAQK,CAAC,EAAIH,EAAKG,CAAC,EAAE,IAAK,EAErC,OAAOF,CACR,CAKAN,EAAO,QAAUC,IC3DjB,IAAAQ,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAS,QAAS,6BAA8B,EAChDC,EAAQ,QAAS,0BAA2B,EAgBhD,SAASC,EAAOC,EAAMC,EAAOC,EAAOC,EAAOC,EAAW,CACrD,IAAIC,EACAC,EAEJ,OAAAA,EAAQJ,EAAM,OACTI,IAAU,EACdD,EAAU,CAAE,CAAE,EAEdA,EAAUP,EAAOQ,CAAM,EAEjB,IAAIN,EAAMC,EAAOJ,EAAQI,EAAO,CAAE,EAAGC,EAAOG,EAAS,EAAGF,EAAO,CACrE,SAAYC,CACb,CAAC,CACF,CAKAR,EAAO,QAAUG,ICzDjB,IAAAQ,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAsB,QAAS,0CAA2C,EAC1EC,EAAuB,QAAS,0CAA2C,EAC3EC,EAAa,QAAS,0BAA2B,EACjDC,EAAO,QAAS,iCAAkC,EAClDC,EAAQ,QAAS,0BAA2B,EAC5CC,EAAQ,QAAS,4BAA6B,EAC9CC,EAAW,QAAS,4BAA6B,EACjDC,EAAW,QAAS,4BAA6B,EACjDC,EAAa,QAAS,8BAA+B,EACrDC,EAAY,QAAS,6BAA8B,EACnDC,EAAW,QAAS,4BAA6B,EACjDC,EAAU,QAAS,kCAAmC,EACtDC,EAAS,QAAS,uBAAwB,EAC1CC,EAAa,IACbC,EAAgB,IAChBC,EAAQ,IAgDZ,SAASC,EAAOC,EAAGC,EAAGC,EAAQC,EAAW,CACxC,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAWJ,GARAP,EAAQjB,EAAUW,CAAE,EACpBO,EAAQjB,EAAUU,EAAG,EAAK,EAC1BI,EAAUb,EAAYS,EAAG,EAAK,EAC9BK,EAASb,EAAWQ,CAAE,EACtBQ,EAAQf,EAAUO,CAAE,EACpBU,EAAQH,EAAM,OAGTN,EAAE,QAAUS,EAChB,MAAM,IAAI,WAAYf,EAAQ,uIAAwIY,EAAM,KAAM,GAAI,EAAGN,EAAE,KAAM,CAAE,EAMpM,GAHAU,EAAOX,EAAE,YAGJU,IAAU,EACd,OAAO,IAAIC,EAAML,EAAOZ,EAASM,CAAE,EAAGO,EAAOH,EAASC,EAAQG,EAAO,CACpE,SAAY,CAACL,CACd,CAAC,EASF,GANAM,EAAQzB,EAAsBiB,CAAE,EAGhCY,EAAK9B,EAAqBkB,EAAGM,EAAO,EAAK,EAGpCM,EAAG,KAAO,CACd,GAAKX,EACJ,MAAM,IAAI,WAAYP,EAAQ,mEAAoEY,EAAM,KAAM,GAAI,CAAE,CAAE,EAGvHM,EAAK9B,EAAqBkB,EAAGM,EAAO,EAAM,EAG1CK,EAAK3B,EAAY4B,CAAG,EAGfzB,EAAOF,EAAM0B,EAAIH,CAAM,CAAE,EAAI,IACjCG,EAAKzB,EAAOyB,EAAG,MAAO,EAExB,MAECA,EAAK3B,EAAY4B,CAAG,EAGrB,OAAKzB,EAAOwB,CAAG,IAAM,EACbd,EAAOa,EAAML,EAAOpB,EAAM0B,EAAIH,CAAM,EAAGD,EAAO,CAACL,CAAS,GAGhEE,EAAST,EAAYiB,EAAIT,EAASC,CAAO,EAGzCO,EAAK1B,EAAM0B,EAAIH,CAAM,EAGhBG,EAAG,SAAW,EACX,IAAID,EAAML,EAAOZ,EAASM,CAAE,EAAG,CAAC,EAAG,CAAE,CAAE,EAAGK,EAAQG,EAAO,CAC/D,SAAY,CAACL,CACd,CAAC,GAGFC,EAAUP,EAAegB,EAAIT,EAASK,CAAM,EAGrC,IAAIE,EAAML,EAAOZ,EAASM,CAAE,EAAGY,EAAIR,EAASC,EAAQG,EAAO,CACjE,SAAY,CAACL,CACd,CAAC,GACF,CAKArB,EAAO,QAAUiB,IC9GjB,IAAIe,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_slice_start", "__commonJSMin", "exports", "module", "sliceStart", "slice", "strides", "offset", "data", "idx", "i", "require_slice_strides", "__commonJSMin", "exports", "module", "slice2strides", "slice", "strides", "rdims", "data", "out", "i", "j", "require_empty", "__commonJSMin", "exports", "module", "buffer", "zeros", "empty", "ctor", "dtype", "shape", "order", "readonly", "strides", "ndims", "require_main", "__commonJSMin", "exports", "module", "normalizeMultiSlice", "nonreducedDimensions", "sliceShape", "take", "zeros", "numel", "getDType", "getShape", "getStrides", "getOffset", "getOrder", "getData", "format", "sliceStart", "slice2strides", "empty", "slice", "x", "s", "strict", "writable", "strides", "offset", "dtype", "shape", "order", "sdims", "ndims", "ctor", "sh", "ns", "main"]
}
